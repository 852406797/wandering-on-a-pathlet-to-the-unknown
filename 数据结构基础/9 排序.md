## 9.2 排序的基本概念与分类

假设含有 \( n \) 个记录的序列为 \(\{r_1, r_2, \ldots, r_n\}\)，其相应的关键字分别为 \(\{k_1, k_2, \ldots, k_n\}\)，需确定 1, 2, \ldots, n 的一种排列 \( p_1, p_2, \ldots, p_n \)，使其相应的关键字满足 \( k_{p_1} \leq k_{p_2} \leq \ldots \leq k_{p_n} \)（非递减或非递增）关系，即使得序列成为一个按关键字有序的序列 \(\{r_{p_1}, r_{p_2}, \ldots, r_{p_n}\}\)，这样的操作就称为**排序**。

假设 \( k_i = k_j \)（\( 1 \leq i < n, 1 \leq j < n, i \neq j \)），且在排序前的序列中 \( r_i \) 领先于 \( r_j \)（即 \( i < j \)）。如果排序后 \( r_i \) 仍领先于 \( r_j \)，则称所用的排序方法是**稳定**的；反之，若可能使得排序后的序列中 \( r_j \) 领先于 \( r_i \)，则称所用的排序方法是**不稳定**的。

**内排序**是在排序整个过程中，待排序的所有记录全部被放置在内存中。**外排序**是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。

内排序分为：插入排序、交换排序、选择排序和归并排序。

## 9.3 冒泡排序

**冒泡排序（Bubble Sort）** 是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。

## 9.4 简单选择排序

**简单选择排序法（Simple Selection Sort）** 就是通过 \( n-i \) 次关键字间的比较，从 \( n-i+1 \) 个记录中选出关键字最小的记录，并和第 \( i \)（\( 1 \leq i < n \)）个记录交换之。

## 9.5 直接插入排序

**直接插入排序（Straight Insertion Sort）** 的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。

## 9.5 希尔排序

所谓**基本有序**，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间。

将相距某个“增量”的记录组合一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。

## 9.7 堆排序

**堆**是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。

**堆排序（Heap Sort）** 就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的 \( n-1 \) 个序列重新构造成一个堆，这样就会得到 \( n \) 个元素中的次小值。如此反复执行，便能得到一个有序序列了。

## 9.8 归并排序

**归并排序（Merging Sort）** 假设初始序列含有 \( n \) 个记录，则可以看成是 \( n \) 个有序的子序列，每个子序列的长度为 1，然后两两归并，得到 \( \lceil n/2 \rceil \)（\( \lceil x \rceil \) 表示不小于 \( x \) 的最小整数）个长度为 2 或 1 的有序子序列；再两两归并，……，如此重复，直至得到一个长度为 \( n \) 的有序序列为止，这种排序方法称为 2 路归并排序。

## 9.9 快速排序

**快速排序（Quick Sort）** 的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。

**三数取中（median-of-three）法**。即取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数。

## 9.10 总结

![性能](https://cdn.jsdelivr.net/gh/852406797/picgopic@main/202412141133549.png)

